/*
 * usart_ring.c
 *
 *  Created on: Dec 10, 2019
 *      Author: kutuk
 */
#include "dcon.h"


uint8_t _DCON_RX_Buffer[DCON_RX_BUFFER_SIZE]= {0,};
uint8_t _DCON_TX_Buffer[DCON_RX_BUFFER_SIZE]= {0,};
uint8_t _CHK_mode=0;																	//Признак включения/выключения контрольной суммы в протоколе DCON
/////////////////// DCON USART /////////////////////


//============ Функция включения/выключения контрольной суммы протокола DCON ===============
//Функция принимает в качестве параметров:
//CHK - Признак включения/выключения контрольной суммы протокола DCON
//Функция возвращает:
//	0x00-успешное завершение работы
uint8_t CHK_Control(uint8_t CHK)
{
	_CHK_mode=CHK;																		//Выбор режима контрольной суммы протокола DCON
	return 0;																			//Успешное завершение функции
}

//======================= Функция чтения данных по протоколу DCON ==========================
//Функция производит чтение содержимого приемного буфера DCON
//Функция принимает:
//*buf-указатель на массив в который будут помещены считанные данные
//Функция возвращает:
//	0x00-если приемный буфер DCON пуст;
//	0x01-данные из приемного буфера перемещены в глобальный массив для чтения;
//	0x80-не совпадение контрольной суммы принятых данных.
//  0xFF-не корректный номер COM порта
//Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
//Нулевой элемент выходного массива содержит количество прочитаных байт.

uint8_t Read_DCON(uint8_t *buf)
{
	int8_t temp;																				//Вспомогательная переменная
	uint8_t CHK_sum=0;																			//Переменная для расчета контрольной суммы

	if (_DCON_RX_end==0) return 0;																//Выход если признак окончания приема не установлен
	_DCON_RX_end=0;																				//Сброс флага окончания приема

	if (_CHK_mode==CRC_EN)																		//Если включена контрольная сумма и текущий протокол DCON
	{
		for (temp=0;temp<_DCON_RX_length-3;temp++) CHK_sum+=_DCON_RX_Buffer[temp];					//Обычное сумирование всех элементов буфера, за исключением CR и самой контрольной суммы
		temp=CHK_sum>>4;																		//Старший символ контрольной суммы
		if (temp<=9) temp+=0x30;																//Если символ цифра (0-9)
		else temp+=0x37;																		//Если символ буква (A-F)
		if (temp!=_DCON_RX_Buffer[_DCON_RX_length-3]) return 0x80;								//Выход если не совпал первый символ контрольной суммы

		temp=CHK_sum & 0x0F;																	//Младший символ контрольной суммы
		if (temp<=9) temp+=0x30;																//Если символ цифра (0-9)
		else temp+=0x37;																		//Если символ буква (A-F)
		if (temp!=_DCON_RX_Buffer[_DCON_RX_length-2]) return 0x80;								//Выход если не совпал второй символ контрольной суммы
	}

	*buf=_DCON_RX_length;																		//Сохранение длинны принятых данных
	for (temp=0; temp<_DCON_RX_length; temp++)													//Перекопирование буфера
	{
		buf++;
		*buf=_DCON_RX_Buffer[temp];
	}

	return 1;																					//Данные прочитаны
}

//======================= Функция записи данных по протоколу DCON ==========================
//Функция принимает:
//*buf - Указатель на строку передаваемых данных
// *DCON_huart Указатель на COM порт
//Функция возвращает:
//	0x00-успешное завершение работы


uint8_t Write_DCON(uint8_t *buf,UART_HandleTypeDef *DCON_huart)
{
	uint8_t CHK_sum=0;																				//Переменная для расчета контрольной суммы
	uint8_t temp;																					//Вспомогательная переменная
	int8_t Length;																					//Длина команды

	Length=0;																					//Обнуление счетчика символов в строке команды
	while (Length < DCON_RX_BUFFER_SIZE)														//Цикл, пока не встретися конец строки, символ возврата каретки или не заполнится буфер
	{
		_DCON_TX_Buffer[Length]=*buf;
		if ((_DCON_TX_Buffer[Length]==0) || (_DCON_TX_Buffer[Length]==0x0D)) break;				//Если достигнут конец строки или встретился символ возврат каретки
		CHK_sum+=_DCON_TX_Buffer[Length];
		Length++;																				//Увеличить счетчик длинны строки команды
		buf++;																					//Переход на следующий символ строки команды
	}

	if (_CHK_mode==CRC_EN)																		//Если включена контрольная сумма и текущий протокол DCON
	{
		temp=CHK_sum>>4;																		//Старший символ контрольной суммы
		if (temp<=9) _DCON_TX_Buffer[Length]=temp+0x30;											//Если символ цифра (0-9)
		else _DCON_TX_Buffer[Length]=temp+0x37;													//Если символ буква (A-F)
		Length++;

		temp=CHK_sum & 0x0F;																	//Младший символ контрольной суммы
		if (temp<=9) _DCON_TX_Buffer[Length]=temp+0x30;											//Если символ цифра (0-9)
		else _DCON_TX_Buffer[Length]=temp+0x37;													//Если символ буква (A-F)
		Length++;
	}

	_DCON_TX_Buffer[Length++]=0x0D;																//Замена символа конца строки на возврат каретки

	HAL_UART_Transmit(DCON_huart, _DCON_TX_Buffer,(uint16_t)Length, 1000);										//Запуск передачи данных по DCON
	return 0;																					//Успешное завершение функции
}
